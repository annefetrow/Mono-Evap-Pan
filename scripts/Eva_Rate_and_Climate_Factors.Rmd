---
title: "Evaporation Rate and Climate Factors"
author: "Yolanda Ming"
date: "`r Sys.Date()`"
output: html_document
---

## Overview

This code contains an analysis of evaporation rates calculated from raw evaporation pan water data, in relation to various climate factors - water and air temperatures, and relative humidity. The goal is to explore how different climate conditions influence evaporation rates, using data analysis and visualization in R. You will also be able to tune the salinity based on your data or understanding.

## Intialization

Before running the code, we defined some global settings and load necessary libraries. You don't need to change the settings but please make sure you have all the libraries downloaded to your computer.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Initialization
cat("\014")
rm(list = ls())
graphics.off()

# Load necessary libraries
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(vroom)
library(gridExtra)
library(grid)
library(cowplot)

# Set default line width globally for plots
theme_set(theme_minimal(base_size = 14))
```

You will need to change the working directory to your own personal computer's directory when you download it. 

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Define global working directory, please change it when download the code to your personal desktop
global_work_dir <- "C:/Users/24468/Desktop/Research/SEAS-HYDRO/Mono Lake/Mono-Evap-Pan"
global_save_dir <- file.path(global_work_dir, "plots")
```

## Functions

In order to simplify main code body, several functions are defined below. You don't need to change the settings for the functions.

The function mainly includes:

* Importing datasets using `readr` or `read.csv`.
* Handling missing values using `na.omit` or `dplyr::filter`.
* Converting date formats and extracting relevant time-based features.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
parse_datetime_flexible <- function(ori_datetime_str) {
  
  # parse_datetime_flexible flexibly parse datetime strings in either mdy_hms or ymd_hms format.
  #
  # Args:
  #   ori_datetime_str: A character vector of datetime strings to parse.
  #
  # Returns:
  #   A POSIXct vector of parsed datetime values. If parsing fails initially, attempts are made to correct and re-parse the strings.
  
  # Attempt initial parsing with mdy_hms format
  parsed_datetime <- mdy_hms(ori_datetime_str, quiet = TRUE)
  
  # If parsing with mdy_hms fails, try ymd_hms
  if (any(is.na(parsed_datetime))) {
    parsed_datetime <- ymd_hms(ori_datetime_str, quiet = TRUE)
  }
  
  # If both mdy_hms and ymd_hms failed, append ":00" to entries that resulted in NA
  if (any(is.na(parsed_datetime))) {
    datetime_str <- ori_datetime_str
    datetime_str[is.na(parsed_datetime)] <- paste0(ori_datetime_str[is.na(parsed_datetime)], ":00")
    
    # Try parsing again with mdy_hms and then ymd_hms on modified datetime strings
    parsed_datetime <- mdy_hms(datetime_str, quiet = TRUE)
    if (any(is.na(parsed_datetime))) {
      parsed_datetime <- ymd_hms(datetime_str, quiet = TRUE)
    }
  }
  
  # Return only YY:MM:DD HH:MM format
  return(format(parsed_datetime, "%Y-%m-%d %H:%M"))
}
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
data_import <- function(file_name, data_column) {
  # data_import reads the data and timestamps from a CSV file.
  #
  # Args:
  #   file_name: Path to the CSV file
  #
  # Returns:
  #   A list containing:
  #     - data: Water level or other data (third column)
  #     - timestamp: Timestamps corresponding to the data (second column)
  
  # Read the CSV file
  data_table <- read.csv(file = file_name, skip = 1, head = TRUE, sep=",")
  
  # Keep only the 2nd and 3rd columns
  data_table <- data_table[, c(2, data_column)]
  
  # Optionally rename columns for easier access (if desired)
  colnames(data_table) <- c("Timestamp", "Value")  # Renaming columns (optional)
  data_table$Timestamp <- parse_datetime_flexible(data_table$Timestamp) # Convert data type to datetime
  
  # Display the resulting data
  print(data_table)
  
  # Return the data and timestamps as a list
  return(list(value = data_table$Value, timestamp = data_table$Timestamp))
}
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
read_and_combine_csv <- function(folder_path, start_file, end_file, data_column) {
  # read_and_combine_csv: Function to read and combine data from multiple CSV files within a specified range.
  #
  # Args:
  #   folder_path: Path to the folder containing the CSV files.
  #   start_file: Index of the first file to process (1-based index).
  #   end_file: Index of the last file to process (1-based index).
  #   data_column: Index of the column containing the data values to extract.
  #
  # Returns:
  #   A data frame containing combined and cleaned data from the specified range of CSV files, with duplicates and NaN values removed.
  
  # Get a list of all CSV files in the folder
  csv_files <- list.files(folder_path, pattern = "*.csv", full.names = TRUE)
  
  # Check if the specified range is valid
  num_files <- length(csv_files)
  if (start_file < 1 || end_file > num_files || start_file > end_file) {
    stop("Invalid file range specified. Please check start_file and end_file indices.")
  }
  
  # Initialize empty data frames to hold combined data
  all_data <- data.frame()
  
  # Loop through each file and read the data
  for (k in start_file:end_file) {
    # Read the CSV file
    data <- data_import(csv_files[k], data_column)
    data$timestamp <- parse_datetime_flexible(data$timestamp)
    
    # Combine the data
    all_data <- bind_rows(all_data, data)
  }
  
  # Remove duplicates and NaN values
  unique_data <- all_data %>%
    distinct() %>%
    filter(!is.na(value) & !is.na(timestamp))
  
  unique_data$timestamp <- as.POSIXct(unique_data$timestamp, format = "%Y-%m-%d %H:%M")
  
  return(unique_data)
}
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
trim_to_common_date_boundaries <- function(data1, time1, data2, time2) {
  
  # trim_to_common_date_boundaries: Function to trim two datasets to a common date range.
  #
  # Args:
  #   data1: A vector containing the first dataset's values.
  #   time1: A vector of datetime values corresponding to data1.
  #   data2: A vector containing the second dataset's values.
  #   time2: A vector of datetime values corresponding to data2.
  #
  # Returns:
  #   A list containing:
  #     - common_date_range: A vector with the start and end of the common date range.
  #     - data1_trimmed: The trimmed values of data1 within the common date range.
  #     - data2_trimmed: The trimmed values of data2 within the common date range.
  #     - time1_trimmed: The trimmed datetime values of time1 within the common date range.
  #     - time2_trimmed: The trimmed datetime values of time2 within the common date range.
  
  # Find the maximum of the start dates and the minimum of the end dates
  common_start <- max(min(time1), min(time2))
  common_end <- min(max(time1), max(time2))
  
  # Create the common date range
  common_date_range <- c(common_start, common_end)
  
  # Trim data1 and data2 to this common date range
  time1_trimmed <- time1[time1 >= common_start & time1 <= common_end]
  data1_trimmed <- data1[time1 >= common_start & time1 <= common_end]
  
  time2_trimmed <- time2[time2 >= common_start & time2 <= common_end]
  data2_trimmed <- data2[time2 >= common_start & time2 <= common_end]
  
  # Return the common date range and trimmed data
  list(common_date_range = common_date_range,
       data1_trimmed = data1_trimmed,
       data2_trimmed = data2_trimmed,
       time1_trimmed = time1_trimmed,
       time2_trimmed = time2_trimmed)
}
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
eva_rate_cal <- function(h, date_time) {
  
  # eva_rate_cal: Function to calculate evaporation rate from a given set of heights and timestamps.
  #
  # Args:
  #   h: A numeric vector containing height values (e.g., water levels).
  #   date_time: A POSIXct vector containing corresponding datetime values.
  #
  # Returns:
  #   A list containing:
  #     - eva_rate: A vector of calculated evaporation rates for each valid window.
  #     - eva_date_time: A vector of mean datetime values corresponding to each valid window.
    
  eva_rate <- c()
  eva_date_time <- as.POSIXct(character())
  
  for (i in 1:(length(h) - 2)) {
    window <- h[i:(i + 2)]
    duration <- as.numeric(difftime(date_time[i + 2], date_time[i], units = "hours"))
    rate <- (window[1] - window[3]) / duration
    eva_rate <- c(eva_rate, rate)
    mean_timestamp <- mean(date_time[i:(i + 2)])
    eva_date_time <- c(eva_date_time, mean_timestamp)  # Mean timestamp for the window
  }
    
  #   if (is.unsorted(-window) == FALSE) {  # Check if window is sorted in descending order
  #     rate <- (window[1] - window[3]) / duration
  #     eva_rate <- c(eva_rate, rate)
  #     mean_timestamp <- mean(date_time[i:(i + 2)])
  #     eva_date_time <- c(eva_date_time, mean_timestamp)  # Mean timestamp for the window
  #   }
  # }
    
    
    
  # Return eva_rate and eva_date_time as a list
  return(list(eva_rate = eva_rate, eva_date_time = eva_date_time))
}
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
export_plot_to_png <- function(plot, file_name, save_dir = global_save_dir, width = 1200, base_height = 200, res = 150, num_rows = 1, combined = FALSE) {
  
  # export_plot_to_png: Function to export a plot or a grid of plots to a PNG file.
  #
  # Args:
  #   plot: The plot to save, can be a single ggplot or a grid of plots.
  #   file_name: The name of the output PNG file.
  #   save_dir: The directory to save the plot in. Default is global_save_dir.
  #   width: The width of the saved image in pixels. Default is 1200.
  #   base_height: The base height of the plot in pixels (without extra space for labels). Default is 200.
  #   res: The resolution of the saved image in dpi (dots per inch). Default is 150.
  #   num_rows: The number of rows in a combined plot (if it's a grid of plots). Default is 1.
  #   combined: A logical indicating whether the plot is a combined (grid) plot. Default is FALSE.
  #
  # Returns:
  #   A PNG file containing the plot, saved to the specified location.
  
  # Adjust height only if it's a combined plot and there are multiple rows
  if (combined && num_rows > 1) {
    # Add extra space for the x-axis labels on the first plot (top plot)
    extra_space_for_labels <- 300  # Adjust this value as needed
  } else {
    extra_space_for_labels <- 0  # No extra space needed for non-combined or single-row plots
    base_height = 400
  }
  
  # Calculate the total height
  height <- base_height * num_rows + extra_space_for_labels
  
  # Create the directory if it doesn't exist
  dir.create(save_dir, showWarnings = FALSE, recursive = TRUE)
  
  # Construct the full file path
  file_path <- file.path(save_dir, file_name)
  
  # Open a PNG device with calculated height
  png(filename = file_path, width = width, height = height, res = res)
  
  # Check if the input is a single plot or a grid object
  if (inherits(plot, "ggplot")) {
    # For a single ggplot, use print
    print(plot)
  } else {
    # For grid-arranged objects, use grid.draw
    grid.draw(plot)
  }
  
  # Close the device
  dev.off()
  
  cat("Plot exported to:", file_path, "\n")
}
```

## Water Level

First, we will load the water level data from the evaporation pan and precipitation data from precipitation gauge. We first just plotted the water level data over time to get an overview of how it changes with time.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Water Level
# Path to the folder containing the CSV files for water level
folderPath <- file.path(global_work_dir, "data", "Raw data - Evaporation Pan","Pan Water Level")
all_data <- read_and_combine_csv(folderPath, 5, 8, 3)

# Precipitation
file_path <- file.path(global_work_dir, "data", "2024_station_data","Precipitation_CQ251.csv")

# Read the CSV file
# Ensure column names match the expected: "date" and "(Modeled) Non-Snow Precipitation (mm of water)"
precipitation_data <- read_csv(file_path, col_types = cols(
  `Date` = col_datetime(format = "%m/%d/%Y %H:%M"),  # Adjust format to match your data
  `(Modeled) Non-Snow Precipitation (mm of water)` = col_double()
))

# Rename columns for easier use
precipitation_data <- precipitation_data %>% 
  rename(
    date = `Date`,
    precipitation = `(Modeled) Non-Snow Precipitation (mm of water)`
  )

# Flip the sign of precipitation values
precipitation_data <- precipitation_data %>%
  mutate(precipitation_negative = -precipitation)

# Plot water level over time
p <- ggplot(all_data, aes(x = timestamp, y = value)) +
  geom_line(color = 'blue') +
  labs(x = 'Date', y = 'Water Level (mm)', title = 'Water Level over Time') +
  theme_minimal()
p

# Export the plot to a png file
export_plot_to_png(p, file_name = "Water_Level.png", num_rows = 1, combined = FALSE)
```

## Evaporation Rate

Using the water level data, we use the center difference method to calculate the evaporation rate. Any positive evaporation rate will be zeroed since it's due to refill or precipitation.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Evaporation Rate Calculation Function
eva_rate <- eva_rate_cal(all_data$value, all_data$timestamp)
eva_rate <- list(
  eva_rate = eva_rate$eva_rate[eva_rate$eva_rate < 3],
  eva_date_time = eva_rate$eva_date_time[eva_rate$eva_rate < 3]
)
eva_rate_avg <- mean(eva_rate$eva_rate, na.rm = TRUE) # exclude outliers

# Plot evaporation rate and precipitation
# Get the maximum and minimum values after cleaning
max_eva <- max(eva_rate$eva_rate, na.rm = TRUE)
max_precip <- min(precipitation_data$precipitation_negative, na.rm = TRUE)

# Plot evaporation rate and precipitation
p <- ggplot() +
  # Evaporation rate plot
  geom_bar(aes(x = eva_rate$eva_date_time, y = eva_rate$eva_rate),
           stat = "identity", fill = "blue", alpha = 0.7) +
  # Precipitation plot
  geom_bar(aes(x = precipitation_data$date, y = precipitation_data$precipitation_negative), 
           stat = "identity", fill = "red", alpha = 0.7) +
  # Horizontal line for average evaporation rate
  geom_hline(yintercept = eva_rate_avg, linetype = "dashed", color = "blue") +
  # Adjust annotation position to avoid out-of-range error
  annotate("text", x = max(eva_rate$eva_date_time) - days(1), 
           y = max_eva + 0.2,  # Adjusted position based on max evaporation rate
           label = paste("Average:", round(eva_rate_avg, 2), "mm/hr"), hjust = 1) +
  # Labels and theme
  labs(x = 'Date', 
       y = 'Rate (mm/hr)', 
       title = 'Evaporation and Precipitation Rates Over Time') +
  theme_minimal() +
  # Set custom y-axis limits
  scale_y_continuous(limits = c(max_precip, max_eva)) +
  # Set correct x-axis limits and format
  scale_x_datetime(limits = c(min(eva_rate$eva_date_time), max(eva_rate$eva_date_time)))
p

# Export the plot to a png file
export_plot_to_png(p, file_name = "Evaporation_Rate_Over_Time.png", num_rows = 1, combined = FALSE)

# Function to calculate daily averages and export to CSV
calculate_and_export_daily_avg <- function(values, date_times, output_path, file_name, col_name) {
  daily_avg <- tibble(Date = as.Date(date_times), Value = values) %>%
    group_by(Date) %>%
    summarize(Daily_Avg = mean(Value, na.rm = TRUE)) %>%
    rename(!!col_name := Daily_Avg)
  write_csv(daily_avg, file.path(output_path, file_name))
  daily_avg
}

# Calculate daily evaporation rate and export
output_folder <- file.path(global_work_dir, "output")
calculate_and_export_daily_avg(eva_rate$eva_rate, eva_rate$eva_date_time, output_folder, 'daily_average_evaporation_rates.csv', 'Evaporation_Rate_mm_hr')
```

## Climate Factors

Here, we just simply importing all the climate factor data from all the gauges and plot them against time. Data are up to date with the latest download. All climate data are stored in `Raw data - Evaporation Pan`.

### Water Temperature

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Water Temperature
folderPath <- file.path(global_work_dir, "data", "Raw data - Evaporation Pan","Water Temp")
water_temp_data <- read_and_combine_csv(folderPath, 1, 2, 3)

p <- ggplot(water_temp_data, aes(x = timestamp, y = value)) +
  geom_line(color = 'red') +
  labs(x = 'Date', y = 'Temperature (°C)', title = 'Water Temperature over Time') +
  theme_minimal()
p

calculate_and_export_daily_avg(water_temp_data$value, water_temp_data$timestamp, output_folder, 'daily_average_water_temperature.csv', 'WaterTemp_C')

export_plot_to_png(p, file_name = "Water_Temperature_over_Time.png", num_rows = 1, combined = FALSE)
```

### Air Temperature

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Air Temperature
folderPath <- file.path(global_work_dir, "data", "Raw data - Evaporation Pan","Air Temp and RH")
air_temp_data <- read_and_combine_csv(folderPath, 1, 2, 3)

p <- ggplot(air_temp_data, aes(x = timestamp, y = value)) +
  geom_line(color = 'green') +
  labs(x = 'Date', y = 'Temperature (C)', title = 'Air Temperature over Time') +
  theme_minimal()
p

calculate_and_export_daily_avg(air_temp_data$value, air_temp_data$timestamp, output_folder, 'daily_average_air_temperature.csv', 'AirTemp_C')

export_plot_to_png(p, file_name = "Air_Temperature_over_Time.png")
```

### Relative Humidity

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Relative Humidity
folderPath <- file.path(global_work_dir, "data", "Raw data - Evaporation Pan","Air Temp and RH")
rh_data <- read_and_combine_csv(folderPath, 1, 2, 4)

p <- ggplot(rh_data, aes(x = timestamp, y = value)) +
  geom_line(color = 'black') +
  labs(x = 'Date', y = 'RH (%)', title = 'Relative Humidity over Time') +
  theme_minimal()
p

calculate_and_export_daily_avg(rh_data$value, rh_data$timestamp, output_folder, 'daily_average_RH.csv', 'RH_Percent')

export_plot_to_png(p, file_name = "Relative_Humidity_Over_Time.png", num_rows = 1, combined = FALSE)
```

## Correlation Between Climate Factors

We plotted the evaporation rate against other climate factors to examine the relationship between them.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
plotByMonth <- function(T_water_all_date_time, T_water_all, T_air_all_date_time, T_air_all, RH_all_date_time, RH_all) {
  
  # Convert date-time columns to Date format if they are not already
  T_water_all_date <- as.Date(T_water_all_date_time)
  T_air_all_date <- as.Date(T_air_all_date_time)
  RH_all_date <- as.Date(RH_all_date_time)
  
  # Get unique months and years from the datetime arrays
  months <- format(T_water_all_date, "%m")
  years <- format(T_water_all_date, "%Y")
  uniqueMonths <- unique(data.frame(year = years, month = months))
  
  # Create an empty list to store the individual plots
  plots <- list()
  
  # Define color mapping for the variables
  color_mapping <- c("Water Temp" = "red", "Air Temp" = "green", "RH" = "black")
  
  # Temperature axis limits
  temp_min <- floor(min(c(T_water_all, T_air_all), na.rm = TRUE))
  temp_max <- ceiling(max(c(T_water_all, T_air_all), na.rm = TRUE))
  
  # RH original scale
  rh_min_orig <- 0
  rh_max_orig <- 100
  
  # Loop through each month (or each iteration in your data)
  for (i in 1:nrow(uniqueMonths)) {
    
    # Get the current month and year for the plot title
    currentMonth <- uniqueMonths$month[i]
    currentYear <- uniqueMonths$year[i]
    
    # Get start and end of the current month
    month_start <- as.POSIXct(paste(currentYear, currentMonth, "01", sep = "-"))
    month_end <- as.POSIXct(paste(currentYear, currentMonth, days_in_month(month_start), sep = "-")) + 
    hours(23) + minutes(59) + seconds(59)
    
    # Filter data for the current month and year
    idxWater <- which(format(T_water_all_date, "%Y-%m") == paste(currentYear, currentMonth, sep = "-"))
    idxAir <- which(format(T_air_all_date, "%Y-%m") == paste(currentYear, currentMonth, sep = "-"))
    idxRH <- which(format(RH_all_date, "%Y-%m") == paste(currentYear, currentMonth, sep = "-"))
    
    # Rescale RH to match temp scale for plotting
  RH_scaled <- scales::rescale(RH_all[idxRH], to = c(temp_min, temp_max))
    
    # Create a data frame for plotting
  plot_data <- data.frame(
  Date_time = c(T_water_all_date_time[idxWater], T_air_all_date_time[idxAir], RH_all_date_time[idxRH]),
  Value = c(T_water_all[idxWater], T_air_all[idxAir], RH_scaled),  # scaled RH
  Variable = factor(
    rep(c("Water Temp", "Air Temp", "RH"),
        times = c(length(idxWater), length(idxAir), length(idxRH)))
  )
)
    
    # Make sure the format is correct for Date_time
    plot_data$Date_time <- as.POSIXct(plot_data$Date_time, format = "%Y-%m-%d %H:%M:%S")
    
    # Create the individual plot
p <- ggplot(plot_data, aes(x = Date_time, y = Value, color = Variable)) +
  geom_line() +
  scale_y_continuous(
    name = "T (C)",
    limits = c(temp_min, temp_max),
    sec.axis = sec_axis(
      trans = ~ scales::rescale(., from = c(temp_min, temp_max), to = c(rh_min_orig, rh_max_orig)),
      name = "RH (%)",
      breaks = c(0, 50, 100)
    )
  ) +
  scale_color_manual(values = color_mapping) +
  scale_x_datetime(
        limits = c(month_start, month_end),
        date_breaks = "8 days",  # Consistent break interval
        date_labels = "%b %d"  # Date label format
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_blank()
  )

    # Add the plot to the list of plots
    plots[[i]] <- p
  }
  
  # Combine all plots in a single layout (arranged vertically)
  combined_plot <- marrangeGrob(grobs = plots, ncol = 1, nrow = nrow(uniqueMonths), top = NULL)
  grid::grid.draw(combined_plot)
  
  # Export the combined plot with dynamic height
  export_plot_to_png(
    combined_plot,
    file_name = "Water_Temperature_Air_Temperature_RH_by_Month.png",
    num_rows = nrow(uniqueMonths), # Pass the number of months
    combined = TRUE  # Indicate this is a combined plot
  )
}


# Plot Water Temperature, Air Temperature, and Relative Humidity
plotByMonth(water_temp_data$timestamp, water_temp_data$value, air_temp_data$timestamp, air_temp_data$value, rh_data$timestamp, rh_data$value)
```

## How Climate Factors Affecting Evaporation

Finally, climate factors water and air temperature are plotted together with evaporation to examine the correlation.

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
plotMonthlyEvapWaterAir <- function(eva_rate, water_temp_data, air_temp_data) {
  
  # Trim the data to the same date range using the helper function
  trimmed_data <- trim_to_common_date_boundaries(eva_rate$eva_rate, eva_rate$eva_date_time, water_temp_data$value, water_temp_data$timestamp)
  common_date_range <- trimmed_data$common_date_range
  trimmed_eva_time <- trimmed_data$time1_trimmed
  trimmed_eva_rate <- trimmed_data$data1_trimmed
  trimmed_temp_time <- trimmed_data$time2_trimmed
  trimmed_temp <- trimmed_data$data2_trimmed
  
  # Filter air temperature data to the common date range
  filter_idx_air <- air_temp_data$timestamp >= common_date_range[1] & air_temp_data$timestamp <= common_date_range[2]
  trimmed_T_air_time <- air_temp_data$timestamp[filter_idx_air]
  trimmed_T_air <- air_temp_data$value[filter_idx_air]
  
  # Extract unique months in the common date range
  unique_months <- unique(month(trimmed_eva_time))
  num_months <- length(unique_months)
  
  
  # Get unique months and years from the datetime arrays
  months <- format(as.Date(trimmed_eva_time), "%m")
  years <- format(as.Date(trimmed_eva_time), "%Y")
  uniqueMonths <- unique(data.frame(year = years, month = months))
  
  # List to store ggplot objects for each subplot
  plots <- vector("list", num_months)
  
  # Loop over each month to create subplots
  for (i in 1:num_months) { 
    # Get the current month and year for the plot title
    currentMonth <- uniqueMonths$month[i]
    currentYear <- uniqueMonths$year[i]
    
    # Filter data for the current month
    month_idx <- month(trimmed_eva_time) == unique_months[i]
    month_data <- data.frame(
      eva_time = trimmed_eva_time[month_idx],
      eva_rate = trimmed_eva_rate[month_idx]
    )
    
    temp_month_idx <- month(trimmed_temp_time) == unique_months[i]
    temp_data <- data.frame(
      temp_time = trimmed_temp_time[temp_month_idx],
      temp_value = trimmed_temp[temp_month_idx]
    )
    
    air_month_idx <- month(trimmed_T_air_time) == unique_months[i]
    air_data <- data.frame(
      air_time = trimmed_T_air_time[air_month_idx],
      air_value = trimmed_T_air[air_month_idx]
    )
    
    # Convert Date_time to POSIXct format for month_data, temp_data, and air_data
    month_data$eva_time <- as.POSIXct(month_data$eva_time, format = "%Y-%m-%d %H:%M:%S")
    temp_data$temp_time <- as.POSIXct(temp_data$temp_time, format = "%Y-%m-%d %H:%M:%S")
    air_data$air_time <- as.POSIXct(air_data$air_time, format = "%Y-%m-%d %H:%M:%S")
    
    # Define the color mapping for the legend
    color_mapping <- c("Water Temp" = "red", "Air Temp" = "green")
    
    # Define the x-axis title element based on the plot index
    x_axis_title <- if (i == num_months) element_text() else element_blank()
    
    # Plot for the current month
    p <- ggplot() +
      # Bar plot for Evaporation Rate
      geom_bar(data = month_data, aes(x = eva_time, y = eva_rate, fill = "Evaporation Rate"), stat = "identity", alpha = 0.6) +
      # Line plot for Water Temperature (dashed)
      geom_line(data = temp_data, aes(x = temp_time, y = temp_value, color = "Water Temp"), linetype = "dashed") +
      # Line plot for Air Temperature (dashed)
      geom_line(data = air_data, aes(x = air_time, y = air_value, color = "Air Temp"), linetype = "dashed") +
      # Customize the y-axis labels and secondary axis for Water Temp and Air Temp
      scale_y_continuous(
        name = "Eva Rate(mm/hr)",
        sec.axis = sec_axis(~ ., name = "T (°C)")
      ) +
      # Set title and x-axis label
      labs(title = paste("Month:", currentYear, "-", unique_months[i]),
           x = "Date") +
      # Apply color mappings to the legend
      scale_color_manual(values = color_mapping) +
      scale_fill_manual(values = c("Evaporation Rate" = "blue")) +  # Fill color for Evaporation Rate bar
      # Apply minimal theme with customized axis labels and title
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5),
        legend.position = "none",  # Hide the legend for individual plots
        axis.text.x = element_text(angle = 0, hjust = 1),  # Rotate x-axis labels for better readability
        axis.title.x = element_blank()  # Use the conditionally set x-axis title
      )
    
    # Store the plot in the list
    plots[[i]] <- ggplotGrob(p)  # Convert ggplot object to grob
  }
  
  # Combine all plots in a single layout (arranged vertically)
  combined_plot <- marrangeGrob(grobs = plots, ncol = 1, nrow = num_months, top = NULL)
  grid::grid.draw(combined_plot)
  
  # Export the combined plot with the legend
  export_plot_to_png(
    combined_plot,
    file_name = "Water_Air_Temperature_Evaporation_Rate_by_Month.png",
    num_rows = num_months,  # Use num_months here
    combined = TRUE  # Indicate this is a combined plot
  )
}

plotMonthlyEvapWaterAir(eva_rate, water_temp_data, air_temp_data)
```